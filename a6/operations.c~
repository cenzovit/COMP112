#include <stdio.h> 
#include <stdarg.h> 
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h> 
#include <stdlib.h> 
#include <unistd.h> 

#include "storage.h"
#include "operations.h"

#define TRUE 1
#define FALSE 0

/* logging of server actions */ 
#define MAXOUT 256 		/* maximum number of output chars for flog */ 
static void flog(const char *fmt, ...) {
    va_list ap;
    char *p; 
    char buf[MAXOUT]; 
    va_start(ap, fmt);
    fprintf(stderr,"[operations: "); 
    vsnprintf(buf,MAXOUT,fmt,ap); 
    for (p=buf; *p && p-buf<MAXOUT; p++) 
	if ((*p)>=' ') 
	    putc(*p,stderr); 
    fprintf(stderr,"]\n"); 
    va_end(ap);
} 

//Function used to update live server list 
void updateList(struct index* root, char* cli_dotted){ 
  struct index *temp = root;
  for( ; ; ){
    //Check if IP is already in list
    if(temp->next != NULL){
      if(strcmp(temp->next->ipa, cli_dotted) == 0){
	break;
      }
      else{
	temp = temp->next;
      }
    }
    else{
      struct index *newIndex = malloc(sizeof(struct index));
      strcpy(newIndex->ipa, cli_dotted);
      newIndex->next = NULL;
      temp->next = newIndex;
      break;
    }
  } 
}

int compareLists(struct index* rootOne, struct index* rootTwo){
  struct index* conductorOne = rootOne;
  struct index* conductorTwo = rootTwo;
  int test = 0;
  while(conductorOne->next != NULL){
    conductorOne = conductorOne->next;
    while(conductorTwo->next != NULL){
      conductorTwo = conductorTwo->next;
      if(strcmp(conductorOne->ipa, conductorTwo->ipa)){
	test = 1;
      }
    }
    if(test == 0){
      return FALSE;
    }  
    test = 0;
  }
  return TRUE;
}

void updateFileList(struct fileList* root, struct fileList* newFile){
  struct fileList *temp = root;
  for( ; ; ){
    if(temp->next != NULL){
      temp = temp->next;
    }
    else{
      temp->next = newFile;
      break;
    }
  } 
}

void deleteBlocks(char* filename, struct fileParts* parts){
  struct fileParts* temp = parts;
  char blockString[10];
  while(temp != NULL){
    sprintf(blockString, "%d", temp->blockNum);
    char* message = malloc(strlen("delete-")+strlen(filename)+strlen(blockString));
    strcpy(message, "delete-");
    strcat(message, filename);
    strcat(message, blockString);
    sendToServer(parts->locationOne, serv_port, message);
    sendToServer(parts->locationTwo, serv_port, message);
    free(message);
    temp = temp->next;
  }
}

int repairRedundancy(struct index* ipRootList, struct fileList* root, int udpsock){
  struct fileList* temp = root->next;
  root->next = NULL;
  int fail = 0;
  while(temp != NULL){
    char* fileName = temp->fileName;
    char* content = (char*)malloc(temp->fileSize);
    int size;
    if(getFromServers(fileName, &content, &size, ipRootList, 
		      root, udpsock, serv_port)){
      fprintf(stderr, "Retrieved File: %s...\n", fileName);
      deleteBlocks(filename, temp->locations);
      checkRepairs(udpsock);
      if(putToServers(fileName, content, serv_port, ipRootList, root)){
	fprintf(stderr, "Repaired File: %s!\n", fileName);
      }
      else{
	fprintf(stderr, "Failed to Repair File: %s!\n", fileName);
	fprintf(stderr, "--removing corrupted blocks from memory, sorry.\n");
	fail = fail+1;
      }
    }
    else{
      fprintf(stderr, "Could Not Retrieve File: %s...\n", fileName);
      fprintf(stderr, "--removing corrupted blocks from memory, sorry.\n");
      deleteBlocks(fileName, temp->locations);
      fail = fail+1;
    }
    temp = temp->next;
  }
  return fail;
}

void sendToServer(char* ip, int port, char* payload){
  int sockfd;
  char *send_line = malloc(strlen(payload));
  struct sockaddr_in recv_addr;

  /* set target address */ 
  memset(&recv_addr, 0, sizeof(recv_addr));
  recv_addr.sin_family = PF_INET;
  inet_pton(PF_INET, ip, &recv_addr.sin_addr);
  recv_addr.sin_port = htons(port);
  strcpy(send_line, payload);
  sockfd = socket(PF_INET, SOCK_DGRAM, 0);
  
  if (sendto(sockfd, send_line, strlen(send_line), 0, 
	     (struct sockaddr *)&recv_addr, sizeof(recv_addr))==(-1)){
    perror("sendto"); 
  }
  free(send_line);
}

int repairs(int sockfd){
  /* client data */
  struct sockaddr_in cli_addr;        /* raw client address */
  int cli_len;                        /* length used */
  char cli_dotted[MAXADDR];           /* string ip address */
  unsigned long cli_ulong;            /* packed ip address */
  struct hostent *cli_hostent;        /* host entry */
  /* message parameters */ 
  char message[MAXMESG]; 		/* message to be read */ 
  int mesglen=0; 			/* message length */ 
  
  flog("udp datagram available on socket %d\n",sockfd); 
  
  /* get a datagram */
  cli_len = sizeof(cli_addr); /* MUST initialize this */
  mesglen = recvfrom(sockfd, message, MAXMESG, 0,
		     (struct sockaddr *) &cli_addr, &cli_len);
  /* get numeric internet address */
  inet_ntop(PF_INET, (void *)&(cli_addr.sin_addr.s_addr),
	    cli_dotted, MAXADDR);
  flog("udp connection from %s\n",cli_dotted);
    
  /* convert numeric internet address to name */
  cli_ulong = cli_addr.sin_addr.s_addr;
  cli_hostent = gethostbyaddr((char *)&cli_ulong, 
			      sizeof(cli_ulong),PF_INET);
  if (cli_hostent) {
    flog("udp host name is %s\n", cli_hostent->h_name);
  } else {
    flog("no name for udp host\n");
  }
  message[mesglen]='\0'; // moot point; makes it a string if possible
  //flog("message is '%s'",message);
  char* command;
  char* filename;
  char* content;
  
  command = strtok(message, "-");
  filename = strtok(NULL, "-");
  content = strtok(NULL, "-");

  //fprintf(stderr, "command: %s\n", command);
  //fprintf(stderr, "filename: %s\n", filename);
  //fprintf(stderr, "content: %s\n", content);

  if(strcmp(message, "delete")){
    flog("message is '%s'",command);
    char* actualName = (char*)malloc(strlen(filename)+strlen(cli_dotted));
    strcpy(actualName, filename);
    strcat(actualName, cli_dotted);
    del(actualName);
    free(actualName);
    return 1;
  }
  else{
    flog("message is not a 'delete', ignore.");
  }
  return 0;
}

int udpGetPart(int sockfd, char** contents, int block, struct index* root){
  /* client data */
  struct sockaddr_in cli_addr;        /* raw client address */
  int cli_len;                        /* length used */
  char cli_dotted[MAXADDR];           /* string ip address */
  unsigned long cli_ulong;            /* packed ip address */
  struct hostent *cli_hostent;        /* host entry */
  /* message parameters */ 
  char message[MAXMESG]; 		/* message to be read */ 
  int mesglen=0; 			/* message length */ 
  
  flog("udp datagram available on socket %d\n",sockfd); 
  
  /* get a datagram */
  cli_len = sizeof(cli_addr); /* MUST initialize this */
  mesglen = recvfrom(sockfd, message, MAXMESG, 0,
		     (struct sockaddr *) &cli_addr, &cli_len);
  /* get numeric internet address */
  inet_ntop(PF_INET, (void *)&(cli_addr.sin_addr.s_addr),
	    cli_dotted, MAXADDR);
  flog("udp connection from %s\n",cli_dotted);
    
  /* convert numeric internet address to name */
  cli_ulong = cli_addr.sin_addr.s_addr;
  cli_hostent = gethostbyaddr((char *)&cli_ulong, 
			      sizeof(cli_ulong),PF_INET);
  if (cli_hostent) {
    flog("udp host name is %s\n", cli_hostent->h_name);
  } else {
    flog("no name for udp host\n");
  }
  message[mesglen]='\0'; // moot point; makes it a string if possible
  //flog("message is '%s'",message);
  char* command;
  char* filename;
  char* content;
  
  command = strtok(message, "-");
  filename = strtok(NULL, "-");
  content = strtok(NULL, "-");

  //fprintf(stderr, "command: %s\n", command);
  //fprintf(stderr, "filename: %s\n", filename);
  //fprintf(stderr, "content: %s\n", content);


  if(strcmp(message, "retrieved") == 0){
    //updateList(root, cli_dotted);
    flog("message is '%s'",command);
    if(block == 0){
      fprintf(stderr, "content: %s", content);
      strcpy(*contents, content);
    }
    else{
      fprintf(stderr, "content: %s", content);
      strcat(*contents, content);
    }
    return 1;
  }
  else if(strcmp(command, "get") == 0){
    //updateList(root, cli_dotted);
    flog("message is '%s'",command);

    char* actualName = (char*)malloc(strlen(filename)+strlen(cli_dotted));
    strcpy(actualName, filename);
    strcat(actualName, cli_dotted);
    int temp;
    char* returned;
    if(get(actualName, &returned, &temp)){
      char* sendCommand = malloc(strlen("retrieved-")+strlen(filename)+strlen(returned)+strlen("-"));
      strcpy(sendCommand, "retrieved-");
      strcat(sendCommand, filename);
      strcat(sendCommand, "-");
      strcat(sendCommand, returned); 
      sendToServer(cli_dotted, serv_port, sendCommand);
    }
    free(actualName);
  }
  else{
    //updateList(root, cli_dotted);
    flog("message is not an 'retrieved' or 'get', ignore.");
  }
  return 0;
}

int redundancyCheck(int sockfd, struct index* root){
  /* client data */
  struct sockaddr_in cli_addr;        /* raw client address */
  int cli_len;                        /* length used */
  char cli_dotted[MAXADDR];           /* string ip address */
  unsigned long cli_ulong;            /* packed ip address */
  struct hostent *cli_hostent;        /* host entry */
  /* message parameters */ 
  char message[MAXMESG]; 		/* message to be read */ 
  int mesglen=0; 			/* message length */ 
  
  flog("udp datagram available on socket %d\n",sockfd); 
  
  /* get a datagram */
  cli_len = sizeof(cli_addr); /* MUST initialize this */
  mesglen = recvfrom(sockfd, message, MAXMESG, 0,
		     (struct sockaddr *) &cli_addr, &cli_len);
  /* get numeric internet address */
  inet_ntop(PF_INET, (void *)&(cli_addr.sin_addr.s_addr),
	    cli_dotted, MAXADDR);
  flog("udp connection from %s\n",cli_dotted);
    
  /* convert numeric internet address to name */
  cli_ulong = cli_addr.sin_addr.s_addr;
  cli_hostent = gethostbyaddr((char *)&cli_ulong, 
			      sizeof(cli_ulong),PF_INET);
  if (cli_hostent) {
    flog("udp host name is %s\n", cli_hostent->h_name);
  } else {
    flog("no name for udp host\n");
  }
  message[mesglen]='\0'; // moot point; makes it a string if possible
  //flog("message is '%s'",message);
  char* command;
  char* filename;
  char* content;
  //char* size;
  //char* returned;
  
  command = strtok(message, "-");
  filename = strtok(NULL, "-");
  content = strtok(NULL, "-");

  //fprintf(stderr, "command: %s\n", command);
  //fprintf(stderr, "filename: %s\n", filename);
  //fprintf(stderr, "content: %s\n", content);

  if(strcmp(message, "ok") == 0){
    //updateList(root, cli_dotted);
    flog("message is '%s'",command);
    return 1;
  }
  else if(strcmp(command, "save") == 0){
    //updateList(root, cli_dotted);
    flog("message is '%s'",command);
    char* newName = malloc(strlen(filename)+strlen(cli_dotted));
    strcpy(newName, filename);
    strcat(newName, cli_dotted);
    if(put(newName, content, sizeof(char)*strlen(content))){
      sendToServer(cli_dotted, serv_port, "ok");
    }
    else{
      sendToServer(cli_dotted, serv_port, "failed");
    }
    free(newName);
  }
  else{
    //updateList(root, cli_dotted);
    flog("message is not an 'ok' or 'save', ignore.");
  }
  return 0;
}

/* called when udp datagram available on a socket 
 * socket: number of socket */ 
void udp(int sockfd, struct index* root) { 
  /* client data */
  struct sockaddr_in cli_addr;        /* raw client address */
  int cli_len;                        /* length used */
  char cli_dotted[MAXADDR];           /* string ip address */
  unsigned long cli_ulong;            /* packed ip address */
  struct hostent *cli_hostent;        /* host entry */
  /* message parameters */ 
  char message[MAXMESG];       	/* message to be read */ 
  int mesglen=0; 			/* message length */ 
  
  flog("udp datagram available on socket %d\n",sockfd); 
  
  /* get a datagram */
  cli_len = sizeof(cli_addr); /* MUST initialize this */
  mesglen = recvfrom(sockfd, message, MAXMESG, 0,
		     (struct sockaddr *) &cli_addr, &cli_len);
  /* get numeric internet address */
  inet_ntop(PF_INET, (void *)&(cli_addr.sin_addr.s_addr),
	    cli_dotted, MAXADDR);
  flog("udp connection from %s\n",cli_dotted);
    
  /* convert numeric internet address to name */
  cli_ulong = cli_addr.sin_addr.s_addr;
  cli_hostent = gethostbyaddr((char *)&cli_ulong, 
			      sizeof(cli_ulong),PF_INET);
  if (cli_hostent) {
    flog("udp host name is %s\n", cli_hostent->h_name);
  } else {
    flog("no name for udp host\n");
  }
  message[mesglen]='\0'; // moot point; makes it a string if possible
  //flog("message is '%s'",message); 
  char* command;
  char* filename;
  char* content;
  //char* size;
  
  command = strtok(message, "-");
  filename = strtok(NULL, "-");
  content = strtok(NULL, "-");

  //fprintf(stderr, "command: %s\n", command);
  //fprintf(stderr, "filename: %s\n", filename);
  //fprintf(stderr, "content: %s\n", content);

  flog("message is '%s'",command); 
  if(strcmp(command, "ping") == 0){
    updateList(root, cli_dotted); 
  }  
  else if(strcmp(command, "save") == 0){
    //updateList(root, cli_dotted);
    char* newName = malloc(strlen(filename)+strlen(cli_dotted));
    strcpy(newName, filename);
    strcat(newName, cli_dotted);
    if(put(newName, content, strlen(content))){
      sendToServer(cli_dotted, serv_port, "ok");
    }
    else{
      sendToServer(cli_dotted, serv_port, "failed");
    }
  }
  else if(strcmp(command, "get") == 0){
    //updateList(root, cli_dotted);
    flog("message is '%s'",command);

    char* actualName = (char*)malloc(strlen(filename)+strlen(cli_dotted));
    strcpy(actualName, filename);
    strcat(actualName, cli_dotted);
    int temp;
    char* returned;
    if(get(actualName, &returned, &temp)){
      char* sendCommand = malloc(strlen("retrieved-")+strlen(filename)+strlen(returned)+strlen("-"));
      strcpy(sendCommand, "retrieved-");
      strcat(sendCommand, filename);
      strcat(sendCommand, "-");
      strcat(sendCommand, returned); 
      sendToServer(cli_dotted, serv_port, sendCommand);
    }
    free(actualName);
  }
  else if(strcmp(command, "delete") == 0){
    flog("message is '%s'",command);
    char* actualName = (char*)malloc(strlen(filename)+strlen(cli_dotted));
    strcpy(actualName, filename);
    strcat(actualName, cli_dotted);
    del(actualName);
    free(actualName);
  }
}
 

/* get a file from storage;
 * name: name of file (in local machine)
 * content: an array of content (result parameter)
 * size: size of file */ 
int get(char *name, char **content, int *size) { 
    if (get_size(name)>=0) {  
	int blocks; 
	*size=get_size(name); 
	blocks = (*size%BLOCKSIZE==0?*size/BLOCKSIZE:*size/BLOCKSIZE+1); 
	if (blocks>0) { 
	    *content= (char *)malloc(BLOCKSIZE*blocks); 
	    int i;
	    for (i=0; i<blocks; i++) 
		get_fblock(name,i,*content+i*BLOCKSIZE); 
        } else { 
	    *content = (char *)malloc(1*sizeof(char)); 
	    **content=0; 
	} 
	return TRUE; 
    } else { 
	return FALSE; 
    } 
} 

/* put a file into storage. 
 * name: local name of file. 
 * content: a character array of content. 
 * size: size of local file. */ 
int put(char *name, char *content, int size) { 
    int blocks; 
    remember_size(name,size); 
    blocks = (size%BLOCKSIZE==0?size/BLOCKSIZE:size/BLOCKSIZE+1); 
    if (blocks>0) { 
	int i; 
	for (i=0; i<blocks; i++) { 
	    int n = next_cblock(); 
	    if (n>=0) { 
		remember_fblock(name,i,content+i*BLOCKSIZE); 
	    } else { 
		flog("no more cache!\n"); 
		return FALSE; 
	    } 
	} 
    } 
    return TRUE; 
} 

/* delete a file from storage 
 * name: name of file (on one machine) */ 
int del(char *name)  {
    if ((get_size(name))>=0) { 
	forget_size(name); 
	forget_file(name);
	return TRUE; 
    } else { 
	return FALSE; 
    } 
} 


